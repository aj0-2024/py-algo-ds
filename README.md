# Python Algorithms and Data structures

Welcome ! This repository contains notes & implementations of various data structures & algorithms. 

> Many algorithms are simple, clear & thought provoking. Some of them are extremely beautiful and mesmerizing.

Purely for educational purpose and not intended for any other use.

- [Python Algorithms and Data structures](#python-algorithms-and-data-structures)
  - [Algorithm Status Table](#algorithm-status-table)
  - [Data structures Status Table](#data-structures-status-table)
  - [Algorithm Review Table](#algorithm-review-table)
  - [Problem sets](#problem-sets)
    - [Searching](#searching)
    - [Basic Sorting](#basic-sorting)
    - [Recursion](#recursion)
    - [Dynamic Programming](#dynamic-programming)
    - [Divide & Conquer](#divide--conquer)
    - [Greedy approach](#greedy-approach)
    - [Iterative approach](#iterative-approach)
  - [TO-DO](#to-do)
  
## Algorithm Status Table
| # | Algorithm Name | Status | 
| -- | -- | -- |
| 1 | Bubble Sort | âœ”ï¸ |
| 2 | Selection Sort | âœ”ï¸ |
| 3 | Insertion Sort | âœ”ï¸ |
| 4 | Heap Sort | ğ„‚ |
| 5 | Merge Sort | âœ”ï¸ | 
| 6 | Quick Sort | âœ”ï¸ |
| 7 | Topological Sort | ğ„‚ |
| 8 | Depth First Search | âœ”ï¸ |
| 9 | Breadth First Search | âœ”ï¸ |
| 10 | A\* Search | ğ„‚ |
| 11 | Binary Search | âœ”ï¸ |
| 12 | Tree Traversals (Pre-Order, Post-Order & In-Order) | âœ”ï¸ |
| 13 | Maximum Subarray Problem | âœ”ï¸ |
| 14 | Lee's Algorithm | ğ„‚ |
| 15 | Flood Fill Algorithm | ğ„‚ | 
| 16 | Floyd Cycle Detection Algorithm | âœ”ï¸ |
| 17 | Longest Increasing Subsequence | ğ„‚ |
| 18 | Union Find Algorithm | ğ„‚ |
| 19 | Kruskal's Algorithm | ğ„‚ | 
| 20 | Floyd Warshall's Algorithm | ğ„‚ |
| 21 | Huffman Coding Compression | ğ„‚ |
| 22 | Euclid's Algorithm for GCD | ğ„‚ |
| 23 | Primality Tests | âœ”ï¸ |
| 24 | Boyer Moore Majority Vote Algorithm | ğ„‚ |
| 25 | Fisher-Yates Shuffle Algorithm | âœ”ï¸ |
| 26 | Fibonacci Series | âœ”ï¸ |
| 27 | Bellman Ford Algorithm | âœ”ï¸ |
| 28 | Number of ways to make change | âœ”ï¸ |
| 29 | Knapsack 0/1 | âœ”ï¸ |
| 30 | Levenshtein Distance | âœ”ï¸ |
| 31 | Matrix Search | âœ”ï¸ |
| 32 | Find Rotation Point | ğ„‚ |
| 33 | Find Duplicate Integer | âœ”ï¸ |
| 34 | Towers of Hanoi | âœ”ï¸ |

## Data structures Status Table

| # | Data Structure | Status |
| -- | -- | -- |
| 1 | Array | ğ„‚ |
| 2 | Vector Array/List | ğ„‚ |
| 3 | Linked List (Single, Double) | âœ”ï¸ |
| 4 | Binary Search Tree | âœ”ï¸ |
| 5 | Min Heap & Max Heap | âœ”ï¸ | 
| 6 | Stack | âœ”ï¸ |
| 7 | Queue | âœ”ï¸ |
| 8 | Dequeue | ğ„‚ |
| 9 | Priority Queue | ğ„‚ |
| 10 | Unweighted Graph | ğ„‚ |
| 11 | Weighted Graph | ğ„‚ |
| 12 | Trie | ğ„‚ |
| 13 | Hash Set | ğ„‚ |
| 14 | Hash Table | ğ„‚ |
| 15 | LSM Tree | ğ„‚ |
| 16 | B Tree | ğ„‚ |
| 17 | AVL Tree | ğ„‚ |
| 18 | Ternanry Search Tree | ğ„‚ |
| 19 | Bloom Filter | ğ„‚ |

## Algorithm Review Table
| # | Algorithm | Num Reviewed | 
| -- | -- | -- |
| 1 | Searching | 4 |
| 2 | Basic Sorting | 3 |
| 3 | Dynamic Programming | 5 |
| 4 | Divide & Conquer | 2 |
| 5 | Recursion | 1 |
| 6 | Iteration | 0 |
| 7 | Greedy Approach | 3 |
| 8 | Matrix Problems | 1 |
| 9 | Array Problems | 0 |
| 10 | Tree Problems | 2 |
| 11 | Geometry Problems | 0 |
| 12 | Bit manipulation Problems | 2 |
| 13 | String Problems | 0 |
| 14 | Probability Problems | 0 |
| 15 | Graph Problems | 0 |
| 16 | Math Problems | 0 |
| 17 | Sliding Window Problems | 1 |
| 18 | Linked List Problems | 0 |
| 19 | Heap Problems | 0 |

## Data structure review table
| # | Data Structure | Num Reviewed |
| -- | -- | -- |
| 1 | Construct Binary Search Tree & Balance It | 0 |
| 2 | Construct Linked List | 0 |
| 3 | Construct Stack | 0 |
| 4 | Construct Queue | 0 |
| 6 | Construct Heap | 0 |
| 7 | Construct a Trie | 0 |
| 8 | Construct AVL tree | 0 |
| 9 | Construct Red-Black tree | 0 |

## Categories

### Searching 
| # | Problem |
| --- | --- |
| 1 | Binary Search |
| 2 | Depth First Search |
| 3 | Breadth First Search |
| 4 | Matrix Search |

### Basic Sorting
| # | Problem |
| --- | --- |
| 1 | Bubble Sort |
| 2 | Insertion Sort |
| 3 | Selection Sort |


### Recursion 
| # | Problem |
| --- | --- |
| 1 | Tree traversals |
| 2 | Binary tree inversion |
| 3 | Binary tree diameter |
| 4 | Permutations |
| 5 | Powerset |
| 6 | Towers of hanoi |
| 7 | Max path sum of a Binary tree |

#### Notes
- Runtime complexity = O(k ^ n) where k = number of branches per each call.

### Iteration
| # | Problem |
| --- | --- |
| 1 | In order traversal |

### Dynamic Programming 
| # | Problem | Notes |
| --- | --- | --- | 
| 1 | Fibonacci series | --- | 
| 2 | Making change with denominations | --- |
| 3 | Minimum number of coins | --- |
| 4 | Cake Thief | --- |
| 5 | Levenshtein Distance | --- |
| 6 | Staircase Traversal | --- |
| 7 | Max Sum Increasing Subsequence | --- |
| 8 | Longest Common Subsequence | Complex runtime analysis |
| 9 | Knapsack Problem | --- |
| 10 | Disk Stacking | --- |

#### Notes
- Dynamic programming is all about incrementally building the final answer by starting from the bottom
or the base case to the answer. We also store values in memory to avoid recomputation.
- Often slower, a faster but less accurate algorithm may exist.
- Always depends on a formula to calculate curr value based on previous values. If you have the 
formula, you can write the code for it.
- In some cases, sliding window approach might lead to an optimized algorithm.
- To reduce space, figure out ways to keep only the required values as you go.
- In some cases, A greedy approach can provide an optimized solution. But make sure it works by
going through several test cases.

#### Approach
- Start with a table with a range of expected output and input (or) if comparing two items, have
each item build gradually in row and column. In some cases your table is flat 1D.
- Get the base case (string - empty etc)
- Dynamic programming works by starting and incrementally solving the problem from the base case.
(Bottom up programming).
- Now write out the output for each cell and figure out the formula. Usually invovles maxes, mins 
and curr value.
- Once you have the formula it should be straight forward to implement code.
- If you need to back track, save pointers and values along with output so far in your table.

#### Notes
- Base case
- Start from minimum
- What to do at each step? how do we update?

### Divide & Conquer 
| # | Problem |
| --- | --- |
| 1 | Maximum subarray problem |
| 2 | Quick sort |
| 3 | Merge sort |

### Greedy approach
| # | Problem |
| --- | --- |
| 1 | Kadane's algorithm |
| 2 | Highest product of 3 |
| 3 | Product of all other numbers |
| 4 | Sunset Views |
| 5 | Merging meeting time |
| 6 | Apple Stocks |
| 7 | Water Area |

#### Notes
- Not always accurate so be careful.
- Next step to consider is Dynamic Programming.

### Matrix Problems
| # | Problem |
| --- | --- |
| 1 | River Sizes |
| 2 | Remove Islands |

### Array Problems
| # | Problem |
| --- | --- |
| 1 | Find duplicate number |
| 2 | Merge meeting times |
| 3 | Reverse string in place |
| 4 | Reverse words in place |
| 5 | Longest Peak |
| 6 | Minimum change you cannot make |

### String Problems 
| # | Problem |
| --- | --- |
| 1 | String Permutation |
| 2 | Word Cloud |
| 3 | Longest Palindrome String |
| 4 | Group Anagrams |
| 5 | IP Addresses |

### Tree Problems
| # | Problem |
| --- | --- |
| 1 | Youngest common ancestor |
| 2 | Valid Binary Search Tree |
| 3 | Second Largest Item in BST |
| 4 | Find closeset value in BST |
| 5 | Calculate Branch Sums |
| 6 | Calculate Node Depths |
| 7 | Min-Height BST |
| 8 | Invert Binary Tree |
| 9 | Binary Tree Diameter |
| 10 | Max path sum |
| 11 | Find kth largest number in BST |
| 12 | Construct BST from in-order traversal |
| 13 | Height balanced Binary Tree |

### Geometry Problems
| # | Problem |
| --- | --- |
| 1 | Recentagle interception problem |

### Bit Manipulation Problems
| # | Problem |
| --- | --- |
| 1 | Drone problem |

### Probability Problems |
| # | Problem |
| --- | --- |
| 1 | In-Place Shuffle |
| 2 | 5-Sided die & 7-Sided die |

### Graph Problems
| # | Problem | Notes |
| --- | --- | --- |
| 1 | Graph Coloring | --- |
| 2 | Mesh Message | Back tracking |
| 3 | Topological sort | Sort jobs based on dependencies |
| 4 | Boggle Board | Using a trie to solve the problem |
| 5 | Number of ways to traverse graph | -- |

#### Notes
- It's easy to make a mistake of drawing the wrong kind of graph (wrong edges if directed).

### Math Problems
| # | Problem |
| --- | --- |
| 1 | Two Egg Problem |
| 2 | Finding the number of ways to reach end from start in a graph |

### Sliding Window Problems 
| # | Problem |
| --- | --- |
| 1 | Staircase Traversal |

### Traversal Problems
| # | Problem |
| --- | --- |
| 1 | Zigzag Traversal |

### Linked List Problems
| # | Problem |
| --- | --- |
| 1 | Find loop, length and return first node |
| 2 | Reverse a linked list | 

### Heap Problems 
| # | Problem |
| --- | --- |
| 1 | Continuous Median |

## Build sequence Problems
| # | Problem |
| --- | --- |
| 1 | Mesh Message |
| 2 | Maximum subsequence sum |
| 3 | Longest common subsequence |

## Complex Runtime analysis
| # | Problem Set |
| --- | --- |
| 1 | String Problems |
| 2 | Graph Problems |
| 3 | Dynamic Programming |

### Review Problems for runtime analysis
| # | Name |
| --- | --- |
| 1 | Boggle Board |

## Errors, Mistakes
| # | Description | Num times |
| --- | --- | --- |
| 1 | Off by one error (Easy to miss) | 4 |
| 2 | Input validation (Checks for empty) | 1 |
| 3 | Improper initialization values | 1 |
| 4 | Incompletely updating temporary variables | 1 |
| 5 | Improper Input Validation | 1 |
| 6 | Sending wrong arguements or in a wrong order | 1 |
| 7 | Infinite while loops | 1 |
| 8 | Understanding the question wrong | 1 |
| 9 | Not considering that array may have duplicate numbers within range | 1 |
| 10 | Sending wrong values in array iteration, or in wrong order | 1 |
| 11 | Drawing the wrong edges in a graph | 1 |
| 12 | Incorrectly reading question, wrong assumptions | 1 |
| 13 | Boolean testing in the opposite way (EX: `not` instead of truthy) | 1 |
| 14 | Referencing variables before assignment | 1 |
| 15 | Index out of bounds error (Forgetting to check for bounds in while loops) | 2 |
| 16 | referencing methods without the `_` usually given to private methods | 3 |
| 17 | Incorrectly updating or using index variables in loops | 1 |
| 18 | Forgetting to back track path in a search (tree, graph) | 2 |

## Unique looping problems
| # | Problem | Description |
| --- | --- | --- |
| 1 | Valid IP addresses from a string | Looping based on groups of 4 |
| 2 | Four Number Sum | Two inner loops ...i and i... which do different things |

## Tips

### While loops
- Check for out of bound errors within the loop.
- Check for early termination.
- There should be an update every loop - no updates in a particular loop will lead to an infinite loop.

### BFS & DFS
- do not use .pop() too early, only when it makes sense.

## TO-DO
- Implement the tree traversals (recursive & iterative in a separate file)
- Finish `Find rotation point`
