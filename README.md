# Python Algorithms and Data structures

Welcome ! This repository contains notes & implementations of various data structures & algorithms.

> Many algorithms are simple, clear & thought-provoking. Some of them are extremely beautiful and mesmerizing.

Purely for educational purpose and not intended for any other use.

\${toc}

## Algorithm Status Table

| #   | Algorithm Name                                     | Status |
| --- | -------------------------------------------------- | ------ |
| 1   | Bubble Sort                                        | ✔︎     |
| 2   | Selection Sort                                     | ✔︎     |
| 3   | Insertion Sort                                     | ✔︎     |
| 4   | Heap Sort                                          | 𐄂      |
| 5   | Merge Sort                                         | ✔︎     |
| 6   | Quick Sort                                         | ✔︎     |
| 7   | Topological Sort                                   | 𐄂      |
| 8   | Depth First Search                                 | ✔︎     |
| 9   | Breadth First Search                               | ✔︎     |
| 10  | A\* Search                                         | 𐄂      |
| 11  | Binary Search                                      | ✔︎     |
| 12  | Tree Traversals (Pre-Order, Post-Order & In-Order) | ✔︎     |
| 13  | Maximum Subarray Problem                           | ✔︎     |
| 14  | Lee's Algorithm                                    | 𐄂      |
| 15  | Flood Fill Algorithm                               | 𐄂      |
| 16  | Floyd Cycle Detection Algorithm                    | ✔︎     |
| 17  | Longest Increasing Subsequence                     | 𐄂      |
| 18  | Union Find Algorithm                               | 𐄂      |
| 19  | Kruskal's Algorithm                                | 𐄂      |
| 20  | Floyd Warshall's Algorithm                         | 𐄂      |
| 21  | Huffman Coding Compression                         | 𐄂      |
| 22  | Euclid's Algorithm for GCD                         | 𐄂      |
| 23  | Primality Tests                                    | ✔︎     |
| 24  | Boyer Moore Majority Vote Algorithm                | 𐄂      |
| 25  | Fisher-Yates Shuffle Algorithm                     | ✔︎     |
| 26  | Fibonacci Series                                   | ✔︎     |
| 27  | Bellman Ford Algorithm                             | ✔︎     |
| 28  | Number of ways to make change                      | ✔︎     |
| 29  | Knapsack 0/1                                       | ✔︎     |
| 30  | Levenshtein Distance                               | ✔︎     |
| 31  | Matrix Search                                      | ✔︎     |
| 32  | Find Rotation Point                                | 𐄂      |
| 33  | Find Duplicate Integer                             | ✔︎     |
| 34  | Towers of Hanoi                                    | ✔︎     |
| 34  | Word Search                                        | ✔︎     |

## Data structures Status Table

| #   | Data Structure               | Status |
| --- | ---------------------------- | ------ |
| 1   | Array                        | 𐄂      |
| 2   | Vector Array/List            | 𐄂      |
| 3   | Linked List (Single, Double) | ✔︎     |
| 4   | Binary Search Tree           | ✔︎     |
| 5   | Min Heap & Max Heap          | ✔︎     |
| 6   | Stack                        | ✔︎     |
| 7   | Queue                        | ✔︎     |
| 8   | Dequeue                      | 𐄂      |
| 9   | Priority Queue               | 𐄂      |
| 10  | Unweighted Graph             | 𐄂      |
| 11  | Weighted Graph               | 𐄂      |
| 12  | Trie                         | 𐄂      |
| 13  | Hash Set                     | 𐄂      |
| 14  | Hash Table                   | 𐄂      |
| 15  | LSM Tree                     | 𐄂      |
| 16  | B Tree                       | 𐄂      |
| 17  | AVL Tree                     | 𐄂      |
| 18  | Ternanry Search Tree         | 𐄂      |
| 19  | Bloom Filter                 | 𐄂      |

## Algorithm Review Table

| #   | Algorithm                 | Num Reviewed |
| --- | ------------------------- | ------------ |
| 1   | Searching                 | 4            |
| 2   | Sorting                   | 3            |
| 3   | Dynamic Programming       | 5            |
| 4   | Divide & Conquer          | 2            |
| 5   | Recursion                 | 1            |
| 6   | Iteration                 | 0            |
| 7   | Greedy Approach           | 3            |
| 8   | Matrix Problems           | 1            |
| 9   | Array Problems            | 0            |
| 10  | Tree Problems             | 2            |
| 11  | Geometry Problems         | 0            |
| 12  | Bit manipulation Problems | 2            |
| 13  | String Problems           | 0            |
| 14  | Probability Problems      | 0            |
| 15  | Graph Problems            | 0            |
| 16  | Math Problems             | 0            |
| 17  | Sliding Window Problems   | 1            |
| 18  | Linked List Problems      | 0            |
| 19  | Heap Problems             | 0            |
| 20  | Trie Problems             | 0            |
| 21  | Path finding algorithms   | 0            |
| 22  | Backtracking problems     | 0            |
| 23  | Geometry Problems         | 0            |

## Data structure review table

| #   | Data Structure                            | Num Reviewed |
| --- | ----------------------------------------- | ------------ |
| 1   | Construct Binary Search Tree & Balance It | 0            |
| 2   | Construct Linked List                     | 0            |
| 3   | Construct Stack                           | 0            |
| 4   | Construct Queue                           | 0            |
| 5   | Construct Heap                            | 0            |
| 6   | Construct a Trie                          | 0            |
| 7   | Construct LRU Cache                       | 0            |

### To learn

| #   | Data Structure           |
| --- | ------------------------ |
| 1   | Construct AVL tree       | 0 |
| 2   | Construct Red-Black tree | 0 |

## Categories

### Geometry Problems

| #   | Problem         |
| --- | --------------- |
| 1   | Square of zeros |
| 2   | Rectangle Mania |

### Searching

| #   | Problem               |
| --- | --------------------- |
| 1   | Binary Search         |
| 2   | Matrix Search         |
| 3   | Shifted binary search |
| 4   | Search for range      |

### Path finding algorithms |

| #   | Problem                                 |
| --- | --------------------------------------- |
| 1   | Path finding with depth first search    |
| 2   | Path finding with breadth first search  |
| 3   | Path finding using A\* search           |
| 4   | Path finding using Dijkstra's algorithm |

### Sorting

| #   | Problem          |
| --- | ---------------- |
| 1   | Bubble Sort      |
| 2   | Insertion Sort   |
| 3   | Selection Sort   |
| 4   | Quick Sort       |
| 5   | Heap Sort        |
| 6   | Merge Sort       |
| 7   | Topological sort |

### Recursion

| #   | Problem                       |
| --- | ----------------------------- |
| 1   | Tree traversals               |
| 2   | Binary tree inversion         |
| 3   | Binary tree diameter          |
| 4   | Permutations                  |
| 5   | Powerset                      |
| 6   | Towers of hanoi               |
| 7   | Max path sum of a Binary tree |
| 8   | Minimax algorithm             |
| 9   | Ambiguous measurements        |

#### Notes

- Runtime complexity = O(k ^ n) where k = number of branches per each call.
- Identify all repeating patterns. This is the key step.
- Steps
  - Pick a simple case (Not too complex, a step above base case Ex: 3 node tree)
  - What should happen at each step? (involves splitting work and merging it back)
  - What is the base case?
- To implement recursion as iterative solutions, use a stack.
  - The stack should probably hold more than one value per iteration.
  - pop() only when needed and peek() first.
  - Order of instructions is very important.

### Iteration

| #   | Problem            |
| --- | ------------------ |
| 1   | In order traversal |

### Dynamic Programming

| #   | Problem                          | Notes                    |
| --- | -------------------------------- | ------------------------ |
| 1   | Fibonacci series                 | ---                      |
| 2   | Making change with denominations | ---                      |
| 3   | Minimum number of coins          | ---                      |
| 4   | Cake Thief                       | ---                      |
| 5   | Levenshtein Distance             | ---                      |
| 6   | Staircase Traversal              | ---                      |
| 7   | Max Sum Increasing Subsequence   | ---                      |
| 8   | Longest Common Subsequence       | Complex runtime analysis |
| 9   | Knapsack Problem                 | ---                      |
| 10  | Disk Stacking                    | ---                      |
| 11  | Max profit with k transactions   | ---                      |
| 12  | Palindrome Partioning Min Cuts   | ---                      |
| 13  | Longest increasing subsequence   | ---                      |

#### Notes

- Dynamic programming is all about incrementally building the final answer by starting from the bottom
  or the base case to the answer. We also store values in memory to avoid recomputation.
- Often slower, a faster but less accurate algorithm may exist.
- Always depends on a formula to calculate curr value based on previous values. If you have the
  formula, you can write the code for it.
- In some cases, sliding window approach might lead to an optimized algorithm.
- To reduce space, figure out ways to keep only the required values as you go.
- In some cases, A greedy approach can provide an optimized solution. But make sure it works by
  going through several test cases.

#### Approach

- Start with a table with a range of expected output and input (or) if comparing two items, have
  each item build gradually in row and column. In some cases your table is flat 1D.
- Get the base case (string - empty etc)
- Dynamic programming works by starting and incrementally solving the problem from the base case.
  (Bottom up programming).
- Now write out the output for each cell and figure out the formula. Usually invovles maxes, mins
  and curr value.
- Once you have the formula it should be straight forward to implement code.
- If you need to back track, save pointers and values along with output so far in your table.

#### Notes

- Base case
- Start from minimum
- What to do at each step? how do we update?

### Divide & Conquer

| #   | Problem                        |
| --- | ------------------------------ |
| 1   | Maximum subarray problem       |
| 2   | Longest increasing subsequence |

### Greedy approach

| #   | Problem                                   |
| --- | ----------------------------------------- |
| 1   | Kadane's algorithm                        |
| 2   | Highest product of 3                      |
| 3   | Product of all other numbers              |
| 4   | Sunset Views                              |
| 5   | Merging meeting time                      |
| 6   | Apple Stocks                              |
| 7   | Water Area                                |
| 8   | Longest substring without repeating chars |

#### Notes

- Not always accurate so be careful.
- Subset of dynamic programming.

### Matrix Problems

| #   | Problem        |
| --- | -------------- |
| 1   | River Sizes    |
| 2   | Remove Islands |

### Array Problems

| #   | Problem                            |
| --- | ---------------------------------- |
| 1   | Find duplicate number              |
| 2   | Merge meeting times                |
| 3   | Reverse string in place            |
| 4   | Minimum change you cannot make     |
| 4   | Quickselect                        |
| 5   | Calendar matching                  |
| 6   | Right smaller than                 |
| 7   | Delete duplicate in a sorted array |
| 8   | Dutch Flag partition               |

#### Notes

- Two pointers, three pointers
- max_so_far, min_so_far
- In a solution where we are tracking direction, check for an edge case where we
  might end up adding the same cell twice.

### String Problems

| #   | Problem                               |
| --- | ------------------------------------- |
| 1   | String Permutation                    |
| 2   | Word Cloud                            |
| 3   | Longest Palindrome String             |
| 4   | Group Anagrams                        |
| 5   | IP Addresses                          |
| 6   | Pattern matcher                       |
| 7   | Longest Common Subsequence            |
| 8   | Longest Substring without duplication |
| 9   | Underscorify Substring                |
| 10  | Pattern Matcher                       |
| 11  | Multi String Search                   |
| 12  | Interweaving Strings                  |
| 13  | Reverse words in a string             |
| 14  | Longest string chain                  |
| 15  | Knuth-Morris-Pratt algorithm          |
| 16  | Rabin-Karp algorithm                  |

#### Notes

- Do not assume that substring patterns start at 0, they can start anywhere.
- Get used to testing strings and algorithm by hand.
- Understanding the question is important, write test cases first.
- Usually involves building a 2D array and comparision.

### Tree Problems

| #   | Problem                               |
| --- | ------------------------------------- |
| 1   | Youngest common ancestor              |
| 2   | Valid Binary Search Tree              |
| 3   | Second Largest Item in BST            |
| 4   | Find closest value in BST             |
| 5   | Calculate Branch Sums                 |
| 6   | Calculate Node Depths                 |
| 7   | Min-Height BST                        |
| 8   | Invert Binary Tree                    |
| 9   | Binary Tree Diameter                  |
| 10  | Max path sum                          |
| 11  | Find kth largest number in BST        |
| 12  | Construct BST from in-order traversal |
| 13  | Height balanced Binary Tree           |
| 14  | Lowest common manager                 |
| 15  | Same BSTs                             |
| 16  | Nodes at distance k                   |
| 17  | Iterative in-order traversal          |
| 18  | Flatten Binary Tree                   |
| 19  | Sum of all node depths                |
| 20  | Number of binary tree topologies      |
| 21  | Finding the minimum spanning tree     |

#### Notes

- If it's a binary search tree problem, think of a solution with min and max values so far.

### Geometry Problems

| #   | Problem                        |
| --- | ------------------------------ |
| 1   | Rectangle interception problem |

### Bit Manipulation Problems

| #   | Problem       |
| --- | ------------- |
| 1   | Drone problem |

### Probability Problems |

| #   | Problem                   |
| --- | ------------------------- |
| 1   | In-Place Shuffle          |
| 2   | 5-Sided die & 7-Sided die |

### Graph Problems

| #   | Problem                          | Notes                                                  |
| --- | -------------------------------- | ------------------------------------------------------ |
| 1   | Graph Coloring                   | Determine if k colors are enough to color the vertices |
| 2   | Mesh Message                     | using backtracking to build path                       |
| 3   | Topological sort                 | Sort jobs based on dependencies                        |
| 4   | Boggle Board                     | Using a trie to solve the problem                      |
| 5   | Number of ways to traverse graph | --                                                     |
| 6   | Airport Connections              | --                                                     |
| 7   | Bridges of Konigsberg            | --                                                     |

#### Notes

- It's easy to make a mistake of drawing the wrong kind of graph (wrong edges if directed).

### Math Problems

| #   | Problem                                                       |
| --- | ------------------------------------------------------------- |
| 1   | Two Egg Problem                                               |
| 2   | Finding the number of ways to reach end from start in a graph |
| 3   | Knight's tour (4x4)                                           |
| 4   | Magic sqaure                                                  |
| 5   | Random sampling (Online & Offline stream)                     |
| 6   | rand7() from rand5(), rand5() from rand7()                    |

### Sliding Window Problems

| #   | Problem             |
| --- | ------------------- |
| 1   | Staircase Traversal |

### Traversal Problems

| #   | Problem          |
| --- | ---------------- |
| 1   | Zigzag Traversal |

### Linked List Problems

| #   | Problem                                 |
| --- | --------------------------------------- |
| 1   | Find loop, length and return first node |
| 2   | Reverse a linked list                   |
| 3   | Rotate/Shift a linked list              |
| 4   | Rearrange linked list                   |
| 5   | Linked List Palindrome                  |

#### Notes

- Dangling pointers are the cause of problems, be sure to disconnect.

### Heap Problems

| #   | Problem           |
| --- | ----------------- |
| 1   | Continuous Median |

### Trie Problems

| #   | Problem             |
| --- | ------------------- |
| 1   | Multi String Search |

### Backtracking problems

| #   | Problem                  | Notes                                               |
| --- | ------------------------ | --------------------------------------------------- |
| 1   | Solving sudoku           | ---                                                 |
| 2   | N Queens puzzle          | Place N Queens so that no queens attacks another    |
| 3   | Flight itinerary problem | ---                                                 |
| 4   | Map coloring problem     | Given k colors, assign them to n regions of a map   |
| 5   | SEND+MORE=MONEY          | Replace letters with digits to satisfy the equation |
| 6   | Circuit board layout     | Fit rectangles inside rectangles                    |

## Build sequence Problems

| #   | Problem                    |
| --- | -------------------------- |
| 1   | Mesh Message               |
| 2   | Maximum subsequence sum    |
| 3   | Longest common subsequence |

## Complex Runtime analysis

| #   | Problem Set         |
| --- | ------------------- |
| 1   | String Problems     |
| 2   | Graph Problems      |
| 3   | Dynamic Programming |

## Edge case questions (Questions with lots of edge cases)

| #   | Problem set       |
| --- | ----------------- |
| 1   | Shorten Path      |
| 2   | Word Cloud        |
| 3   | Roman numerals    |
| 4   | Calendar Matching |

### Review Problems for runtime analysis

| #   | Name         |
| --- | ------------ |
| 1   | Boggle Board |

## Most Common Errors

### Off by one error

### Understanding the question wrong or failing to get complete requirements

- Writing the test cases and discussing with interviewers helps here.

### Infinite while loops

- Missed updating the index in certain condition (using a cursor instead of to_visit).
- Missed tracking visited in a graph which can cause loops.

## Errors Stats

| Description                                                                                            | Num times |
| ------------------------------------------------------------------------------------------------------ | --------- |
| Off by one error                                                                                       | 28        |
| Infinite while loops (miss updating the index, missed tracking visited)                                | 18        |
| Understanding the question wrong                                                                       | 14        |
| Index out of bounds error (Forgetting to check for bounds in while loops, if conditions and for loops) | 14        |
| Input or 3rd party library result validation (Checks for empty, in inner functions as well as main)    | 5         |
| Editing an incomplete or unfinished code leading to a cascade of errors                                | 4         |
| Improper initialization values (None instead of infinities)                                            | 3         |
| Incompletely updating temporary variables or replacing with None (if conditions etc)                   | 3         |
| Assuming the intended pattern starts only a 0, it can start anywhere in between                        | 3         |
| referencing methods without the `_` usually given to private methods                                   | 3         |
| Forgetting to back track path in a search (tree, graph)                                                | 2         |
| Comparison b/w numbers( +ve, -ve) , initialize with "inf" or "-inf"                                    | 3         |
| Forgetting to cover all cases for if conditions                                                        | 2         |
| Append takes only one argument                                                                         | 2         |
| Spelling mistakes while writing variable names                                                         | 2         |
| Sending wrong arguments or in a wrong order                                                            | 2         |
| Not considering that array may have duplicate numbers within range                                     | 1         |
| Sending wrong values in array iteration, or in wrong order                                             | 1         |
| Drawing the wrong edges in a graph                                                                     | 1         |
| Incorrectly reading question, wrong assumptions                                                        | 1         |
| Boolean testing in the opposite way (EX: `not` instead of truthy)                                      | 1         |
| Referencing variables before assignment                                                                | 1         |
| Incorrectly updating or using index variables in loops                                                 | 1         |
| Not checking if hash table does not have a key (It raises an exception)                                | 1         |
| Comparison at the wrong depth when dealing with 2D arrays or data-structures                           | 1         |
| Forgetting to consider how we use input (Ex: for negative numbers, using abs())                        | 1         |
| Missing the recursion base case leading to infinite calls                                              | 1         |
| Appending wrong type to a list, creating a list with multiple types                                    | 1         |
| Not testing for Empty ([]) or with one item ["a"]                                                      | 1         |
| Not unpacking properly                                                                                 | 1         |
| Forgetting to add padding for number to string conversions (ex: time conversions)                      | 1         |
| Improperly checking conditions (Ex: calendar matching)                                                 | 1         |
| Forgetting to update some of the tracking variables in a while loop                                    | 1         |
| Declaring and using tracking variables too early                                                       | 1         |
| Forgetting to type cast between layers                                                                 | 1         |
| Adding two different types (None + number)                                                             | 1         |
| Infinite recursion (Wrong base case - off by one, etc)                                                 | 1         |
| Returning null values and forgetting to check for null in the upper functions                          | 1         |
| Jumping to conclusions too early without verifying                                                     | 1         |
| Misinterpreting types                                                                                  | 1         |
| Forgetting to send all arguments to a function                                                         | 1         |
| Using same names for multiple temporary variables                                                      | 1         |
| Forgetting the possibilities of negative and fractional values                                         | 1         |
| Using continue or break statements too early                                                           | 1         |
| Using comparisons operators on None                                                                    | 1         |
| not returning any values from a function                                                               | 1         |
| Renaming variables and not updating the function properly                                              | 1         |
| Not initializing the step properly in a For loop                                                       | 1         |

### Off by one errors

- Be careful with `>`, `<`, `>=`, `<=`. These usually cause errors at boundaries.

## Unique looping problems

| #   | Problem                          | Description                                             |
| --- | -------------------------------- | ------------------------------------------------------- |
| 1   | Valid IP addresses from a string | Looping based on groups of 4                            |
| 2   | Four Number Sum                  | Two inner loops ...i and i... which do different things |

## Tips

### While loops

- Check for out of bound errors within the loop.
- Check for early termination.
- There should be an update every loop - no updates in a particular loop will lead to an infinite loop.

### BFS & DFS

- do not use .pop() too early, only when it makes sense.

## Math Propblems

### The Math Book (Clifford A. Pickover)

- Calculating Pi (Pg 60)
- Sieve of Erathosthenes (Pg 62)
- Wheat on a chess board (pg 102)
- Projective Geometry (Pg 142)
- Torricelli's Trumpet (Pg 144)
- Pascal's Triangle (Pg 146)
- Viviani's Theorem (Pg 150)
- Rope around the earth puzzle (Pg 162)
- Konigsberg Bridges (Pg 174)
- Goldbach conjecture
- Euler's polygon division problem
- Magic Square (pg 190)
- Minimal Surface (Pg 192)
- Knight's tour
- Buffon's Needle (Pg 194)
- Thirty-six Officers Problem (Pg 196)

## TO-DO

- Implement the tree traversals (recursive & iterative in a separate file).
- Learning how to convert recursion solutions into iterative ones.
- Converting str time to int time and int time to str time.
- Balancing a Binary search Tree.
- Implement a Bloom Filter.
- Implement a hashing algorithm.

## To-review

- Go over algorithms that guarantee randomness.

## Overall Programming Notes

- Keep an eye on the common errors, repeat as less as possible.
- Occam's razor (Look for the simplest idea that can solve the problem)
- Two Key Points:
  - What is the base case (given and default).
  - Figure out what to do at each step to get to the answer.
- Splitting by functionality makes testing easier in head or paper.

## Problem solving steps

- Completely understand the problem with test cases and discussing with peers or interviewers.
  This is the most vital step.
- Once you have an understanding of the problem, look at your past knowledge and see which area can
  help solve this problem.
- It is vital to transpose the problem into different areas to see if it can help solve it.
- Once you have a basic algorithm that can solve all the test cases. Identify repeated work and try
  to reduce it.
- Reduce unnecessary space usage.

## Number notes

- Num digits in a number for base b = floor(math.log(x, b)) + 1

## Bit manipulation notes

- `x & (x - 1)` = x with its lowest set bit erased.
- `x & ~(x - 1)` = isolate the lowest bit.
- XOR is commutative(order) & associative(grouping).

## Editor Notes

- Keep your editor configuration very simple.
- Use your brain most of the time.
- Use vim paired with tmux.
